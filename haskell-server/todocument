
## Bugs

- http://stackoverflow.com/questions/44053564/react-dnd-unable-to-drag-element
  https://github.com/react-dnd/react-dnd/issues/766

## Document

- https://www.w3schools.com/tags/ref_urlencode.asp - use it to get encoded versions of urls

- Marked is a previewer for markdown. If you use it pay for it. Just open a file 
  and it tracks as you make changes.

- Every drag source must specify it by returning an object from its beginDrag() method.

- Add api call to initialize the tray and to replenishPiece.

- Submitted a question.

  https://github.com/react-dnd/react-dnd/issues/640

- https://reacttraining.com/online

- div flexDirection: row

- npm start
  npm test
  webpack

- Seems like you can't really have private instance variables
  in class objects.

  That seems to indicate that using the module pattern from
  Crockford may be better. Inside a function you have private variables,
  and what you return from the function has closed on those variables.

  So return an object from the function, call the function immediately.

- Document. stack build &> build.out

- Dan Abramov - at github gaearson is him.

      dan.abramov@me.com

- Stackage for searching.

Refl 

:k 4
:k "game"
:k ReaderT

Kinds

* 
Symbol
Nat
Constraint - e.g., type class, type equality - goes before =>
* -> *

type family

type family - a function at the the level of types

type family function-name formal parameter - define it
  the defined types have to be the same kind for various actual parameters

can be closed or open

associated type family

define a more general type class that has parameters that are kinds

you can define type families in there

class is HasServer

  ServerT is defined as a type family inside here

:t
:k
:info HasServer

they have defined instances for the the >: and :<|> combinators


proxy useful when you have a composition of two functions - the value passed between
the two functions becomes the type parameter of the proxy, so that the user
can specify which type to use, without actually being able to get at that 
intermediate value

errors with Servant - handler already uses ExceptT, so you just throw Error
ServantError


- Add to slides - 

  If we have both IO and Either and try to use IO (Either Err Val)
  then each time we call a function, we have to do case analysis
  for either before we can use the next function.

    ExceptT obviates this need, because it threads together functions
    of the substrate so you don't have to deal with eithers.

- ghci - let ioList :: IO [Int]; ioList = return list

- Research. Why is refactoring so bad for react javascript?



I have been working on a [simplified] scrabble program in Haskell and I now have
it limping with a React user interface. The server-side program has a web api
interface (Servant) and database backend (Persistent and Esqueleto). If there is
interest, I'd be willing to present my program as a case study in real-world
Haskell. The way I would go about it is to present the overall architecture in
40 minutes, then have folks team up and browse the code for 40 minutes, and then
have a 40 minute general discussion about idioms, patterns, style, and
alternative designs.

I can do this sometime this summer or fall if there is interest.

- Document. https://begriffs.com/posts/2017-04-09-monad-tutorial-workshop.html

- ad-hoc polymorphism via typeclass context - compare with interfaces
  compare with generic polymorphism

- Change elevator to "mutual proxy pattern" and describe it
  independently of Haskell for any nesting of data structures.

  Then go to the Haskell representation of it. And MTL's use of it.

  Can you establish a parallel with Lenses?

- Document - own ids not db ids for application. Db id only for db relationships.

  Use persistent ids for the db, but your own for application.

- http://gettingsharper.de/2014/01/24/babysteps-in-using-persistent-to-interact-with-postgresql/

- In order to have flexibility of using uuids for ids, we make all
  ids strings. But for initial simplicity we just use auto-increment.
  Need to convert id to string and back. Add to design.

  Or maybe don't do auto-increment. Who knows about auto-increment?

- case and if within do block - just work - how?

- Document - must have qualified fields consistently for all data 
  structures. Otherwise, you may use an unqualified field when
  it shoul dhave been qualified, and the compiler thinks it is the other
  data structure that has unqualified field.

- Document differences of Except something, liftIO something, and ExceptT 
  return something.

- Document. Note that the json is not dependent on the names of 
  the types or the constructors. Just the field names.

- Document.

  https://hackage.haskell.org/package/servant-server-0.10/docs/Servant-Server.html

  https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html
     This where you should be looking.

  http://hspec.github.io/expectations.html

  Document - http://hspec.github.io

- Document this in a README. Use prefixed method calls mostly and import qualified. 
  Explicitly import everything. See GameService.

- Haskell. To reduce heavines - create local functions with short names 
  for prefixed functions.

- Document. private in javascript just put it outside the class.

- stack haddock - will tell you % of 

- stack command that continues watching 

  stack build --file-watch

- Can have a module that imports and re-exports for a whole 'package'.

- List could be inefficient for large sets. Use set from containers.
- Document - to slides

    In general rather than using a specific monad, use an mtl type class
    that abstracts the specific functions provided by that monad.
    Here rather than Either we use MonadError.

    That is the practical crux of the use of the elevator pattern.

- All code just reduces to 

      MonadSometing m => .... -> m something
   
   liftIO needs another context for MonadIO

     (MyMonad m, MonadIO m) => 

- Stick to Haskell notation for the talk. 
  Use the dot notation and the ab for a->b notation just for subscripting 
  with types. Explain that it is to be taken as a comment - but shorter 
  notation that a comment for the slide. Don't use this notation
  in lieu of Haskell - just in addition.

- Document - slides - 

      complex numbers representing reality - the Geometry professor
      waves represent reality - Feynman

- Document - maybe good name - resolve reader monad of the stack
  resolve logger monad of he stack.

- the flag -p requires the program to be built with -prof

- Profiling - 

  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html

  Compile with -prof and -fprof-auto options. Run the program. 
  Check the generated results.

  stack build --profile

  stack exec prog -p

- https://www.robinwieruch.de/react-eslint-webpack-babel/

- https://ajsblackbelt.wordpress.com/2014/05/18/jasmine-tests-expect-tothrow/comment-page-1/

- return promise from the function - good practice so that 
  callers can add then etc to the promise.

- mongo db - good way to generate promises to work with

- react create class - no more - just define a class

  add propTypes the class as a separate statement

- pattern matching (deconstruction) works also in nested data structures

- field name can be implied by the variable name

- Set is a standard data structure - use it instead of implementing set as list.

- The this value used in arrow functions is actually fetched lexically from the
  scope it sits inside. It has no this, so when you use this youâ€™re talking to the
  outer scope.

  For a regular function - if you call not as a method, this is picked up
  from the call site. 

  The bind() method creates a new function that, when called, has its this keyword
  set to the provided value, with a given sequence of arguments preceding any
  provided when the new function is called. Just creates a closure.

- destructuring assignment

- test.skip

- Document. Intellij. preferences - languages - javascript - libraries - added flux from
  noed_modules. Then use the + to add specific files of directores.
  Use Debug for uncompressed code.

  From the project panel go into node_modules and flux and bring up 
  Dispatcher.js. Put a breakpoint there. It will be recognized.

- Document ES7 async await.

  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await

- Document - testing with promises.

  https://facebook.github.io/jest/docs/setup-teardown.html
  https://facebook.github.io/jest/docs/asynchronous.html

- Monad transformer slide 37 wrong - should not use return.

- Review monad transformer slides and extend if possible.
  Add use of mtl transformer context to make functions generic.

